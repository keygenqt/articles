# Сложность

Бывали ли вы в ситуации, когда решенная задача не подходила по условиям времени выполнения или использования ресурсов?
Часто, для решения задачи недостаточно получить только результат, так же важно получить эффективный способ ее решения.
Многие программисты уделяют много времени поиску эффективного алгоритма решения поставленной задачи,
тем самым сокращая потребление ресурсов используемых устройств и увеличивая себе зарплату :v:

![Sink about it](https://api.keygenqt.com/api/ps/file/d053ef4b-b0e2-442e-8058-3811c5f062e2.jpg)

### Эффективность

Эффективность выражается в количестве затраченного времени и выделения памяти под реализацию.
*Время работы* - важнейший параметр.
Отличия времени выполнения оптимального решения и решения в "лоб" может отличаться очень значительно.
*Выделения памяти* - другой важный параметр, определяющий эффективность.
Кстати, велика вероятность того, что если вы не уложились по времени, вряд ли вам удастся уложиться по памяти.
Алгоритм должен быть *прост в реализации*, иметь возможность *повторного использования*, не забывайте вам или вашему коллеге возможно еще придется работать с этим кодом.

### Асимптотическая сложность

*Асимптотическая сложность* (или просто *сложность*) алгоритма определяется функцией, которая указывает как ухудшается работа алгоритма при усложнении поставленной задачи.
Она определяется функцией, которую пишут в круглых скобках с буквой O.

Например `O(N²)`, или еще можно записать так `O(N^2)`, означает, что при увеличении количества входных данных в 2 раза, выполнение замедлится в 4 раза, в 3 раза - замедлится в 9 раз.

<div class="PrettyImage">
  <img src="https://api.keygenqt.com/api/ps/file/6004ee21-dd3a-4ad9-9193-e843c436e03f.jpg"/>
</div>

#### Функция `O(1)`

Алгоритм с такой производительностью выполняется за одинаковый период времени независимо от количества элементов.
Как правило, речь идет об ограниченном круге команд, поскольку за `O(1)` невозможно даже перебрать поступающие данные.

```javascript
const arr = [1, 2, 3, 4, 5];
console.log(arr[2]) // => 3
```

#### Функция `O(log N)`

Алгоритм с производительностью функциии `O(log N)` делит количество элементов на фиксированный коэффициент при каждом шаге.
Например, если для вычисления элементов требуется 1 секунда, то для вычисления 10 элементов потребуются 2 секунды, для вычисления 100 элементов — 3 секунды и так далее.

```javascript
const count = 100
for (let i = 1; i < count; i *= 2) {
    console.log("Hey - I'm busy looking at: " + i);
}
```

#### Функция `O(N)`

Алгоритм с такой сложностью возрастает линейно относительно количества элементов.
То есть, пропорционально количеству элементов.
Если для вычисления элементов требуется 1 секунда, то для вычисления 10 элементов потребуются 10 секунд, для вычисления 100 элементов — 100 и так далее.

```javascript
const count = 100
for (let i = 1; i < count; i++) {
    console.log("Hey - I'm busy looking at: " + i);
}
```

#### Функция `O(N log N)`

Алгоритм с такой производительностью на каждом шаге выполняет обработку элемента.
Любой алгоритм, который многократно делит набор данных пополам, а затем обрабатывает эти половины независимо с помощью подалгоритма, который имеет временную сложность `O(N)`, будет иметь общую временную сложность `O(N log N)`.

```javascript
const count = 100
for (let i = 1; i <= count; i++) {
    for (let j = 1; j < count; j = j * 2) {
        console.log("Hey - I'm busy looking at: " + i + " and " + j);
    }
}
```

#### Функция `O(N^2)`

В алгоритме с производительностью `O(N^2)` выполняется перебор каждого элемента, при котором для каждого элемента осуществляется перебор каждого элемента.
Возможны и другие степени N, например `O(N^3)` или `O(N^4)`, они значительно медленнее.

```javascript
const count = 100
for (let i = 1; i <= count; i++) {
    for (let j = 1; j <= count; j++) {
        console.log("Hey - I'm busy looking at: " + i + " and " + j);
    }
}
```

#### Функция `O(2^N)`

Экспоненциальная функция возрастает молниеносно и применима для узкого круга задач.
Часто может быть заменена на [эвристический алгоритм](https://ru.wikipedia.org/wiki/Эвристический_алгоритм) — дающий приемлемый результат, но не наилучший.

```javascript
const count = 100
for (let i = 1; i <= Math.pow(2, count); i++) {
    console.log("Hey - I'm busy looking at: " + i);
}
```

#### Функция `O(N!)`

“N факториал”. С подобной скоростью роста функции, как правило, ищут оптимальное распределение входных данных.
Она возрастает намного быстрее, чем экспоненциальная функция `O(2^N)`.

```javascript
const count = 100

const factorial = (num) => {
    if (num < 0)
        return -1;
    else if (num === 0)
        return 1;
    else {
        return (num * factorial(num - 1));
    }
}

for (let i = 1; i <= factorial(count); i++) {
    console.log("Hey - I'm busy looking at: " + i);
}
```

### Пессимистичная и средняя сложность

Не всегда имеющиеся данные одинаковы и выполняются с единой сложностью.
Если алгоритм зависит от типа данных, как составить точную функцию сложности?
В таких ситуациях чаще всего используются [пессимистичная сложность](https://en.wikipedia.org/wiki/Worst-case_complexity), либо [средняя сложность](https://ru.wikipedia.org/wiki/Сложность_алгоритма_в_среднем).
В олимпиадных задачах под словом “сложность” обычно понимают пессимистичную сложность.
В таких случаях берется худший результат из возможных вариантов входящих данных.
